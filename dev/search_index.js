var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Exported-symbols","page":"Reference","title":"Exported symbols","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"@swizzle\nswizzle\nswizzle!","category":"page"},{"location":"reference/#Swizzles.@swizzle","page":"Reference","title":"Swizzles.@swizzle","text":"@swizzle v.xyz\n@swizzle v.rgb\n@swizzle T v.xyz\n@swizzle v[].some.expression().xyz\n@swizzle v.xyz = [1, 2, 3]\n@swizzle v.rgb = v.bgr\n@swizzle begin\n  a.yz = b.xz\n  b.w = a.x\nend\n\nPerform a swizzling operation, extracting components or, if an assignment is provided, mutating them.\n\nThis macro translates x.<field1><field2>...<fieldn> field access syntax (e.g. x.xwyz) in the provided expression into an appropriate call to swizzle (non-mutating) or swizzle! (mutating).\n\nAn additional type argument T may be provided to put the result of a non-mutating swizzle extraction into a specific type (see the documentation for swizzle for more details). It has no effect on mutating swizzles.\n\nEach letter on the right-hand side of any . is considered as a separate component name, and is by default mapped to:\n\nx or r -> first component\ny or g -> second component\nz or b -> third component\nw or a -> fourth component\n\nusing nomenclature from geometry processing ([x, y, z, w] representing spatial coordinates) and computer graphics ([r, g, b, a] representing color vectors).\n\nThis mapping may be customized from Julia 1.11 onwards (see extended help).\n\nExtended help\n\nFrom Julia 1.11 onwards, scoped values allow the customization of this component mapping, via @with Swizzles.component_names => Dict(...). For example, if you wanted to consider width, height and depth as first, second and third components, you may do\n\nnew_names = Dict('w' => 1, 'h' => 2, 'd' => 3)\n\n# You might also have done `@with Swizzles.component_names[] => new_names`\n# to discard existing names.\n@with Swizzles.component_names => merge(Swizzles.component_names[], new_names) begin\n  # Note: the `@eval` is important here.\n  # It prevents `@swizzle` from being executed before the scoped value is set.\n  @eval begin\n    @swizzle [10, 20, 30].w\n    @swizzle [10, 20, 30].whd\n  end\n  # `@swizzle` macrocalls in `include`d files will also be affected.\n  include(\"file.jl\")\nend\n\nFor convenience, you could even define your own @swizzle macro shadowing the one exported by this package as\n\nusing Swizzles\n\nmacro _swizzle(ex)\n  new_names = Dict('w' => 1, 'h' => 2, 'd' => 3)\n  swizzle_ex = @with Swizzles.component_names => merge(Swizzles.component_names[], new_names) begin\n    # One might also pass around a `T` parameter as second argument.\n    Swizzles.generate_swizzle_expr(ex)\n  end\n  esc(swizzle_ex)\nend\n\n@_swizzle [10, 20, 30].hd\n\nWhether or not this is a good idea is for you to decide.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Swizzles.swizzle","page":"Reference","title":"Swizzles.swizzle","text":"swizzle(v, indices...)\nswizzle(T, v, indices...)\n\nCreate a new object made up of v[i₁], v[i₂], ... where indices = (i₁, i₂, ...). If a type is provided as first argument, the result will be wrapped into it via construct_swizzle.\n\nA default type is derived from swizzle(v, indices...), where a single index infers T = eltype(v), and multiple indices infer T = typeof(v). For statically sized vectors (StaticVector and SizedVector), an extension extends StaticArraysCore vectors such that one of correct size is used to hold the result.\n\nSee also: swizzle!\n\n\n\n\n\n","category":"function"},{"location":"reference/#Swizzles.swizzle!","page":"Reference","title":"Swizzles.swizzle!","text":"swizzle!(v, value, indices...)\n\nMutate v at indices such that v[i₁] = value[1], v[i₂] = value[2], ... where indices = (i₁, i₂, ...). and return value.\n\nIf any indices are duplicated in indices, v will be consecutively overwritten at the corresponding index, retaining the last value per the semantics of setindex!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Non-exported-symbols","page":"Reference","title":"Non-exported symbols","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Swizzles.construct_swizzle may be useful to extend for your own types.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Swizzles.construct_swizzle","category":"page"},{"location":"reference/#Swizzles.construct_swizzle","page":"Reference","title":"Swizzles.construct_swizzle","text":"construct_swizzle(T, args)\n\nWrap the result of a swizzling operation into T(args...).\n\nThis method may be extended for your own types, e.g. if a different constructor must be used.\n\nSee also: swizzle\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Swizzles","category":"page"},{"location":"#Swizzles","page":"Home","title":"Swizzles","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation for Swizzles, a small package designed to express swizzling operations, notably relevant for computer graphics and shader programming.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Check out the Tutorial to get started, the Motivation section to understand more about the purpose of this package, or the API reference for technical documentation.","category":"page"},{"location":"motivation/#Motivation","page":"Motivation","title":"Motivation","text":"","category":"section"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"This package is largely motivated by the use of swizzling in computer graphics. It is common to write shaders which use built-in vector types to represent many kinds of data, not just position. Notably, 4-component vectors are particularly efficient to use in hardware and map well to 3D locations using a fourth homogeneous coordinate, which faciliates the application of projective geometry techniques.","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"Because of the efficiency of built-in vectors and special intrinsics defined for them (that may or may not have optimized hardware implementations), it is common for shaders to abuse 2, 3 or 4-component vectors outside of spatial descriptions, where for example 3 or 4-component vectors represent colors (depending on whether an alpha channel is used). In fact, the way shader code integrates with the graphics pipeline in graphics APIs requires colors to be 4-component vectors in fragment shaders. Another example might be to use a 2-component vector to store a strength and a radius parameter for a blur computation algorithm. It does not mean that this is necessarily more efficient than having a user-defined structure with explicit fields, and it is certainly less intuitive to abuse vectors here, but such abuse is widespread in graphics programming.","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"To facilitate the integration of graphics programming code and techniques, it is therefore useful to represent certain operations that are specific to vectors and probably not expected outside of computer graphics, swizzling being one such operation. At its core, swizzling is really just a way to reorder data, using vectors as a way to organize such data.","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"The main appeal to represent swizzling as a function (and provide a convenient syntax for it) is that swizzles are extremely cheap on the GPU. Therefore, a shader compiler such as SPIRV.jl may want to override swizzle methods to emit a single GPU intrinsic for the operation, hinging on the existence of such a function in the first place.","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"After an attempt to allow swizzling in getproperty/setproperty! in StaticArrays (containing the main implementation of small statically-sized vectors), it was decided that having it in an external package was preferable.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"tutorial.jl\"","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Hello there! If you are curious about what swizzling can do and how to do it with this package, you are at the right place.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, make sure that the package is installed and loaded, and let us create a vector to swizzle:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Swizzles\n\nv4 = [10, 20, 30, 40]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The most common use of swizzling would be to extract part of a vector. Say v4 represents a position in homogeneous coordinates, and we'd like to get the euclidean part. We would select the first three components, then divide by the fourth:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"p = v4[1:3]/v4[4]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"But we can do it in a way that is slightly more readable by using named accessors, like so:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"p = @swizzle(v4.xyz)/@swizzle(v4.w)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This is the most basic usage of swizzling. More advanced usage would include swizzling for modifying part of a vector, or reorder components. For that, we'll use colors to better keep track of components.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Colors\n\nv4 = [RGB(1.0, 0.0, 0.0), RGB(0.0, 1.0, 0.0), RGB(0.0, 0.0, 1.0), RGB(0.5, 0.5, 0.5)]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It so happens that swizzling is often used in context where vectors represent color components, where [x, y, z, w] represent the [r, g, b, a] color channels. Therefore, we decided to support color-based component names by default, such that one can do","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"p = @swizzle v4.rgb","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You'll have noted that the various components of p are not actual color channels, so there is a clear abuse of language here. A single channel would have to be a single number, not a 3-channel RGB color value. Now, let's for example reverse the order of the first three components:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@swizzle p.rgb = p.bgr\np","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This could have been achieved with p[1:3] = p[3:-1:1] (or even reverse(p), but that's cheating) which is still quite readable. However, swizzling syntax shines when the indexing patterns are not so linear. As p no longer holds actual red, green and blue data in order, we'll use spatial accessors to reduce confusion.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@swizzle p.xz = p.zx\np","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There we got back our original vector!","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@swizzle v4.rga = v4.bar\nv4","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Compare this to what would be done without the syntax:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# This allocates!\n\np[[1, 3]] = p[[3, 1]]\nv4[[1, 2, 4]] = v4[[3, 4, 1]]\n\n# This is just more verbose (though arguably clearer for certain situations;\n# less does not necessarily mean better).\n\np[1] = p[3]\np[3] = p[1]\n\nv4[1] = v4[3]\nv4[2] = v4[4]\nv4[4] = v4[1]\n\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The value of this swizzling functionality is more apparent when there are lots of operations of this sort, in shaders for example. Although in computer graphics, it will be much more common to use statically-sized vectors; swizzling works on them too!","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using StaticArrays\n\nv = @SVector [1.0, 2.0, 3.0]\n@swizzle v.xy","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@swizzle will attempt to recognize a top-level swizzling expression, therefore you may need to put parentheses and/or perform multiple macrocalls to swizzle different bits of a single expression.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"struct ShaderData\n  location::SVector{4,Float32}\n  # ...\nend\n\ndata = ShaderData(@SVector [2.1, 2.2, 2.3, 2.0])\n\n@swizzle(data.location.xyz)/@swizzle(data.location.w)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"That ends this brief tutorial. You may consult the API reference for more in-depth information about syntax and functionality.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
